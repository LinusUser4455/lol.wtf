local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()
local Version = "1.4.0"
local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI/" .. Version))()

local Window = WindUI:CreateWindow({
    Title = "lol.wtf | Privado", -- UI Title
    Icon = "https://cdn.discordapp.com/attachments/1327852730533806163/1328898819181645875/1000003223-removebg-preview.png?ex=678860f8&is=67870f78&hm=158cce7758f0b11b01fa9fb4881fb3a9b26f182c7b9acfac8a0494b96191b66a&", -- Url or rbxassetid or lucide
    Author = "Scoot And Yuki", -- Author & Creator
    Folder = ",lol ", -- Folder name for saving data (And key)
    Size = UDim2.fromOffset(580, 460), -- UI Size
    KeySystem = { -- Creates key system
        Key = ".lol2e35efeafee9cd5c78dd3be3f02fa469af44", -- key
        Note = "Não Vendo So 5 Pessoas Tem a Key Otaru .,.", -- Note
        URL = "https://discord.gg/T2YVE5dQ", -- URL To get key (example: Discord)
        SaveKey = true, -- Saves the key in the folder specified above
    }, 
    Transparent = true,-- UI Transparency
    Theme = "Dark", -- UI Theme
    SideBarWidth = 170, -- UI Sidebar Width (number)
    HasOutline = true, -- Adds Outlines to the window
})

Window:EditOpenButton({
    Title = ".lol On",
    Icon = "https://cdn.discordapp.com/attachments/1327852730533806163/1328898819181645875/1000003223-removebg-preview.png?ex=678860f8&is=67870f78&hm=158cce7758f0b11b01fa9fb4881fb3a9b26f182c7b9acfac8a0494b96191b66a&",
    CornerRadius = UDim.new(0,10),
    StrokeThickness = 2,
    Color = ColorSequence.new( -- gradient
        Color3.fromHex("000000"), 
        Color3.fromHex("000000")
    )
})

local MainTab = Window:Tab({
    Title = "Main",
    Icon = "folder", -- lucide or rbxassetid
})

local Section = MainTab:Section({ 
    Title = "Aimbot",
    TextXAlignment = "Left",
    TextSize = 17, -- Default Size
})

local Toggle = MainTab:Toggle({
    Title = "CamLock",
    Desc = "Key.Q",
    Value = false,
    Callback = function(state)
        getgenv().Mist = {
            ["Main"] = {
                ["Prediction"] = 0.1666279438888,
                ["AutoPrediction"] = false,-- // 100 ping
                ["AimPart"] = "HumanoidRootPart",
                ["ToggleKey"] = "q" -- // FOR PC
            },
            ["Misc"] = {
                ["AutoAir"] = true,
                ["AntiGroundShots"] = true -- // keep this true for better experience
            }
        }
        
        loadstring(game:HttpGet("https://raw.githubusercontent.com/4r8z/Mist.lol/refs/heads/main/MistCamlockOP", true))()
    end,
})

local Toggle = MainTab:Toggle({
    Title = "SilentAim",
    Desc = "Fov On No Key",
    Value = false,
    Callback = function(state)
    --// Script Config \\--
getrenv().Script = {
    --// Settings \\--
    Settings = {
        --// Silent-Aim - Settings \\--
        SilentAim = {
            Enabled = true,
            AimPart = "ClosestPart", --// Advanced: ClosestPart, RootPart (HumanoidRootPart) \\--
            HitChance = 100,
            Method = "Remote Hook", --// Remote Hook, Mouse Hook, Remote Fire \\--
            
            --// 
            Targeting = {
                Method = "Normal", --// Normal, Closest, Furthest \\--
                Distance = {
                    Minimum = 0,
                    Maximum = math.huge,
                },
            },
            
            Prediction = {
                Enabled = true,
                Method = "Multiplication", --// Multiplication, Division \\--
                
                Multiplication = {
                    Horizontal = 0.134,
                    Vertical = 0.134,
                },
                
                Division = {
                    Horizontal = 6.5,
                    Vertical = 10,
                },
                
                Automatic = {
                    Enabled = true,
                    
                    Horizontal = {
                        Add = 0.134,
                        Multiply = 0.134,
                        Divide = 160,
                    },
                    
                    Vertical = {
                        Add = 0.134,
                        Multiply = 0.134,
                        Divide = 320,
                    },
                },
                
            },
            
        },
        
        --// Triggerbot - Settings \\--
        Triggerbot = {
            Enabled = false,
            ActivationDelay = 0.25,
        },
        
        --// Checks - Settings \\--
        Checks = {
            Wall = true,
            Knocked = true,
            Death = true,
            Grabbed = true,
            Friend = false,
            Crew = true,
            ForceField = true,
        },
        
        --// Velocity - Settings \\--
        Velocity = {
            Type = "Velocity", --// Velocity, AssemblyLinearVelocity \\--
            
            Minimum = {
                X = -math.huge,
                Y = -math.huge,
                Z = -math.huge,
            },
            
            Maximum = {
                X = math.huge,
                Y = math.huge,
                Z = math.huge,
            },
        },
        
        --// Offsets Settings \\--
        Offsets = {
            Enabled = false,
            Jumping = 0,
            Falling = 0,
        },
        
        --// Resolver - Settings \\--
        Resolver = {
            Enabled = false,
            Method = "Recalculate Velocity", --// Recalculate Velocity, Move Direction, Move Velocity \\--
            Smoothness = {
                Enabled = false,
                Value = 0.15,
            },
        },
        
        --// Circle - Settings \\--
        Circle = {
            Visible = true,
            Transparency = 1,
            Color = Color3.fromRGB(255, 255, 255),
            Radius = 250,
            Position = "Crosshair", --// Crosshair, Center, Finger, Mouse \\--
            
            --// Circle Gradient Settings \\--
            Gradient = {
                Enabled = true,
                Rotation = 0,
                
                Colors = {
                    One = Color3.fromRGB(255, 255, 255),
                    Two = Color3.fromRGB(0, 0, 0),
                },
                
                --// Circle Gradient Animation Settings \\--
                Animation = {
                    Enabled = false,
                    Speed = 1,
                    Offset = Vector2.new(0, 0),
                },
            },
            
            --// Circle Stroke Settings \\--
            Stroke = {
                Visible = true,
                Transparency = 0,
                Thickness = 2.5,
                Color = Color3.fromRGB(255, 255, 255),
                
                --// Circle Stroke Gradient Settings \\--
                Gradient = {
                    Enabled = true,
                    Rotation = 0,
                    
                    Colors = {
                        One = Color3.fromRGB(255, 255, 255),
                        Two = Color3.fromRGB(0, 0, 0),
                    },
                    
                    --// Circle Stroke Gradient Animation Settings \\--
                    Animation = {
                        Enabled = true,
                        Speed = 1,
                        Offset = Vector2.new(0, 0),
                    },
                },
                
            },
        },
    },
}

-- Dahood Silent-Aim [NEW]
loadstring(Game:HttpGet("https://raw.githubusercontent.com/TheRealXORA/Roblox/refs/heads/Main/Scripts%20/Dahood%20Silent-Aim.lua", true))()
    end,
})

local Toggle = MainTab:Toggle({
    Title = "Hitbox",
    Desc = "Ctrl+E To increase hitbox | V To hide Hitbox",
    Value = false,
    Callback = function(state)
        loadstring(game:HttpGet('https://raw.githubusercontent.com/realbullett/legacy/refs/heads/main/PrettyMuchThePrettySoftwareFlux'))()
    end,
})

local Button = MainTab:Button({
    Title = "Resolver",
    Desc = "Op",
    Callback = function()
        local Players = game:GetService("Players")

local function calculateVelocity(humanoid)
    local lastPosition = humanoid.RootPart.Position
    local lastTime = tick()

    return function()
        local currentPosition = humanoid.RootPart.Position
        local currentTime = tick()
        local deltaTime = currentTime - lastTime

        local predictedVelocity = (currentPosition - lastPosition) / deltaTime

        lastPosition = currentPosition
        lastTime = currentTime

        return predictedVelocity
    end
end

local function updateHumanoidVelocity(player)
    local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local velocityFunc = calculateVelocity(humanoid)

        humanoid:GetPropertyChangedSignal("RootPart"):Connect(function()
            local velocity = velocityFunc()

            humanoid.WalkSpeed = velocity.magnitude * 0.132
            humanoid.MoveDirection = velocity.unit
        end)
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    updateHumanoidVelocity(player)
end

Players.PlayerAdded:Connect(updateHumanoidVelocity)
    end,
})

local Button = MainTab:Button({
    Title = "AutoShoot",
    Desc = "Op",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Creatingtesting/BateAutoShoot/main/By/ezterminals"))()
    end,
})

local Visual PlayerTab = Window:Tab({
    Title = "Player",
    Icon = "folder", -- lucide or rbxassetid
})

local Section = PlayerTab:Section({ 
    Title = "Visual",
    TextXAlignment = "Left",
    TextSize = 17, -- Default Size
})

local Toggle = PlayerTab:Toggle({
    Title = "Wallhack",
    Desc = "All Games Da Hood",
    Value = true,
    Callback = function(state)
        local FillColor = Color3.fromRGB(175,25,255)
        local DepthMode = "AlwaysOnTop"
        local FillTransparency = 0.5
        local OutlineColor = Color3.fromRGB(255,255,255)
        local OutlineTransparency = 0
        
        local CoreGui = game:FindService("CoreGui")
        local Players = game:FindService("Players")
        local lp = Players.LocalPlayer
        local connections = {}
        
        local Storage = Instance.new("Folder")
        Storage.Parent = CoreGui
        Storage.Name = "Highlight_Storage"
        
        local function Highlight(plr)
            local Highlight = Instance.new("Highlight")
            Highlight.Name = plr.Name
            Highlight.FillColor = FillColor
            Highlight.DepthMode = DepthMode
            Highlight.FillTransparency = FillTransparency
            Highlight.OutlineColor = OutlineColor
            Highlight.OutlineTransparency = 0
            Highlight.Parent = Storage
            
            local plrchar = plr.Character
            if plrchar then
                Highlight.Adornee = plrchar
            end
        
            connections[plr] = plr.CharacterAdded:Connect(function(char)
                Highlight.Adornee = char
            end)
        end
        
        Players.PlayerAdded:Connect(Highlight)
        for i,v in next, Players:GetPlayers() do
            Highlight(v)
        end
        
        Players.PlayerRemoving:Connect(function(plr)
            local plrname = plr.Name
            if Storage[plrname] then
                Storage[plrname]:Destroy()
            end
            if connections[plr] then
                connections[plr]:Disconnect()
            end
        end)
    end,
})

local Button = PlayerTab:Button({
    Title = "AntiLock",
    Desc = "All Games Da Hood",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Gwaporoblox/Sub-to-vascal/main/Vascal-antilock-button"))()
    end,
})

local MiscTab = Window:Tab({
    Title = "Misc",
    Icon = "folder", -- lucide or rbxassetid
})

local Section = MiscTab:Section({ 
    Title = "Obs",
    TextXAlignment = "Left",
    TextSize = 17, -- Default Size
})

local Button = MiscTab:Button({
    Title = "Anti AimViwer",
    Desc = "Bom Para Disfarçar",
    Callback = function()
        local China = setmetatable({}, {
            __index = function(Company, Price)
                return game:GetService(Price)
            end})
            
         local Players = China.Players
         local ReplicatedStorage = China.ReplicatedStorage
         
         --//Variables
         local LocalPlayer = Players.LocalPlayer
         local Mouse =  LocalPlayer:GetMouse()
         
         local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent") or nil
         local Tool = nil
         
         Bypass = function(Entity)
            Entity.ChildAdded:Connect(function(Child)
                if Child:IsA("Tool") then
                  Tool = Child.Activated:Connect(function()
                        if MainEvent then
                           MainEvent:FireServer("UpdateMousePos", Mouse.Hit.Position)
                        end
                    end)
                end
            end)
         end
         
         
         
         local Alive = function(Player)
            return Player and Player.Character and Player.Character:FindFirstChild("Humanoid") and Player.Character:FindFirstChild("Head") or false
         end
         
         LocalPlayer.CharacterAdded:Connect(function(Character)
            Bypass(Character)
         end)
         
         if Alive(LocalPlayer) then
            LocalPlayer.Character.Humanoid:UnequipTools()
            Bypass(LocalPlayer.Character)
         end
         
         local Hook
         Hook = hookmetamethod(game, "__namecall", function(self, ...)
            local Args = {...}
            local Method = getnamecallmethod()
         
            if not checkcaller() and Method == "FireServer" and self.Name == "MainEvent" and Args[1] == "UpdateMousePos" then
         
               Args[2] = "Scarcin made this" and Mouse.Hit.Position
                
                return self.FireServer(self, unpack(Args))
            end
            
            return Hook(self, ...)
         end)
    end,
})

local Button = MiscTab:Button({
    Title = "Trigger Bot",
    Desc = "Op All Games Da Hood",
    Callback = function()
        local configs = {
            main = {
                enabled = true,
                aimlockkey = "c",
                prediction = 0.01125,
                aimpart = 'HumanoidRootPart', -- Head, UpperTorso, HumanoidRootPart, LowerTorso
                notifications = true
            }
        }
        
        -- box / marker settings
        
        local boxsettings = {
            box = {
                Showbox = true,
        
                boxsize = Vector3.new(1.45, 3.75, 1.45), -- Box Size
                markercolor = Color3.fromRGB(1, 120, 145), -- Marrker Color
                markersize = UDim2.new(0, 0, 0, 0) -- Marker Size
            }
        }
        
        -- dont mess with anything below
        local box = Instance.new("Part", game.Workspace)
        
        local Mouse = game.Players.LocalPlayer:GetMouse()
        
        function makemarker(Parent, Adornee, Color, Size, Size2)
            local box = Instance.new("BillboardGui", Parent)
            box.Name = "UwU"
            box.Adornee = Adornee
            box.Size = UDim2.new(Size, Size2, Size, Size2)
            box.AlwaysOnTop = true
        
            local a = Instance.new("Frame", box)
            a.Size = boxsettings.box.markersize
            a.BackgroundColor3 = Color
        
            local g = Instance.new("UICorner", a)
            g.CornerRadius = UDim.new(50, 25)
            return (box)
        end
        
        local Plr
        Mouse.KeyDown:Connect(function(KeyPressed)
            if KeyPressed == (configs.main.aimlockkey) then
                if configs.main.enabled == true then
                    configs.main.enabled = false
                    if configs.main.notifications == true then
                        Plr = FindClosestUser()
                       
                    end
                else
                    Plr = FindClosestUser()
                    configs.main.enabled = true
                    if configs.main.notifications == true then
                    end
                end
            end
        end)
        
        game:GetService('UserInputService').InputBegan:Connect(function(key)
            if key.KeyCode == Enum.KeyCode.K then 
                configs.main.prediction = 0.115
                if configs.main.notifications == true then
                end
            elseif key.KeyCode == Enum.KeyCode.F then 
                configs.main.prediction = 0.096
                if configs.main.notifications == true then
                end
            elseif key.KeyCode == Enum.KeyCode.G then
                configs.main.prediction = 0.103525
                if configs.main.notifications == true then
                end
            end
        end)
        
        local data = game.Players:GetPlayers()
        function noob(player)
            local character
            repeat
                wait()
            until player.Character
            local handler = makemarker(guimain, player.Character:WaitForChild(configs.main.aimpart),
                Color3.fromRGB(107, 184, 255), 0.10, 8)
            handler.Name = player.Name
            player.CharacterAdded:connect(function(Char)
                handler.Adornee = Char:WaitForChild("HumanoidRootPart")
            end)
        end
        
        for i = 1, #data do
            if data[i] ~= game.Players.LocalPlayer then
                noob(data[i])
            end
        end
        
        game.Players.PlayerAdded:connect(function(Player)
            noob(Player)
        end)
        
        spawn(function()
            box.Anchored = true
            box.CanCollide = false
            box.Size = boxsettings.box.boxsize
            if boxsettings.box.Showbox == true then
                box.Transparency = 1
            else
                box.Transparency = 1
            end
            makemarker(box, box, boxsettings.box.markercolor, 0.40, 1)
        end)
        
        function FindClosestUser()
            local closestPlayer
            local ShortestDistance = 300
        
            for i, v in pairs(game.Players:GetPlayers()) do
                if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and
                    v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") then
                    local pos = game:GetService "Workspace".CurrentCamera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
                    local magnitude = (Vector2.new(pos.X, pos.Y) -
                                          Vector2.new(game.Players.LocalPlayer:GetMouse().X,
                            game.Players.LocalPlayer:GetMouse().Y)).magnitude
                    if magnitude < ShortestDistance then
                        closestPlayer = v
                        ShortestDistance = magnitude
                    end
                end
            end
            return closestPlayer
        end
        
        game:GetService "RunService".Stepped:connect(function()
            if configs.main.enabled and Plr.Character and Plr.Character:FindFirstChild("HumanoidRootPart") then
                box.CFrame = CFrame.new(Plr.Character[configs.main.aimpart].Position +
                                            (Plr.Character.UpperTorso.Velocity * configs.main.prediction))
            else
                box.CFrame = CFrame.new(0, 9999, 0)
            end
        end)
        
        --[[repeat
            wait()
        until game:IsLoaded()
        local mt = getrawmetatable(game)
        local old = mt.__namecall
        setreadonly(mt, false)
        mt.__namecall = newcclosure(function(...)
            local args = {...}
            if configs.main.enabled and getnamecallmethod() == "FireServer" and args[2] == "UpdateMousePos" then
                args[3] = Plr.Character[configs.main.aimpart].Position +
                              (Plr.Character[configs.main.aimpart].Velocity * configs.main.prediction)
                return old(unpack(args))
            end
            return old(...)
        end)
        ]]--
        
        -- triggerbot 
        
        local HoldClick = false
        local Hotkey = 'v' -- Leave blank for always on
        local HotkeyToggle = true -- True if you want it to toggle on and off with a click
        
        local Players = game:GetService('Players')
        local RunService = game:GetService('RunService')
        
        local LocalPlayer = Players.LocalPlayer
        local Mouse = LocalPlayer:GetMouse()
        
        local Toggle = (Hotkey ~= '')
        local CurrentlyPressed = false
        
        Mouse.KeyDown:Connect(function(key)
            if HotkeyToggle == true and key == Hotkey then
                Toggle = not Toggle
            elseif key == Hotkey then
                Toggle = true
            end
        end)
        
        Mouse.KeyUp:Connect(function(key)
            if HotkeyToggle ~= true and key == Hotkey then
                Toggle = false
            end
        end)
        
        RunService.RenderStepped:Connect(function()
            task.wait(.25)
            if Toggle then
                if Mouse.Target then
                    if Mouse.Target:FindFirstChild("UwU") then
                        if HoldClick then
                            if not CurrentlyPressed then
                                CurrentlyPressed = true
                                mouse1press()
                            end
                        else
                            mouse1click()
                        end
                    else
                        if HoldClick then
                            CurrentlyPressed = false
                            mouse1release()
                        end
                    end
                end
            end
        end)
    end,
})

local Button = MiscTab:Button({
    Title = "FpsBooster",
    Desc = "Bom Para Melhorar Seu Ping e Seu Fps",
    Callback = function()
        _G.UwpOptimize = {
            Players = {
                ["Ignore Me"] = true, -- Ignore your Character
                ["Ignore Others"] = true-- Ignore other Characters
            },
            Meshes = {
                Destroy = false, -- Destroy Meshes
                LowDetail = true, -- Low detail meshes (NOT SURE IT DOES ANYTHING)
            },
            Images = {
                Invisible = true, -- Invisible Images
                LowDetail = true, -- Low detail images (NOT SURE IT DOES ANYTHING)
                Destroy = false, -- Destroy Images
            },
            ["No Particles"] = true, -- Disables all ParticleEmitter, Trail, Smoke, Fire and Sparkles
            ["No Camera Effects"] = true, -- Disables all PostEffect's (Camera/Lighting Effects)
            ["No Explosions"] = true, -- Makes Explosion's invisible
            ["No Clothes"] = false, -- Removes Clothing from the game
            ["Low Water Graphics"] = true, -- Removes Water Quality
            ["No Shadows"] = false, -- Remove Shadows
            ["Low Rendering"] = true, -- Lower Rendering
            ["Low Quality Parts"] = false, -- Lower quality parts
        }
        
        
        if not _G.Ignore then
            _G.Ignore = {} -- Add Instances to this table to ignore them (e.g. _G.Ignore = {workspace.Map, workspace.Map2})
        end
        if not _G.WaitPerAmount then
            _G.WaitPerAmount = 500 -- Set Higher or Lower depending on your computer's performance
        end
        if _G.SendNotifications == nil then
            _G.SendNotifications = false -- Set to false if you don't want notifications
        end
        if _G.ConsoleLogs == nil then
            _G.ConsoleLogs = false -- Set to true if you want console logs (mainly for debugging)
        end
        
        
        
        if not game:IsLoaded() then
            repeat
                task.wait()
            until game:IsLoaded()
        end
        if not _G.UwpOptimize then
            _G.UwpOptimize = {
                Players = {
                    ["Ignore Me"] = true,
                    ["Ignore Others"] = true,
                    ["Ignore Tools"] = true
                },
                Meshes = {
                    NoMesh = false,
                    NoTexture = false,
                    Destroy = false
                },
                Images = {
                    Invisible = true,
                    Destroy = false
                },
                Explosions = {
                    Smaller = true,
                    Invisible = false, -- Not recommended for PVP games
                    Destroy = false -- Not recommended for PVP games
                },
                Particles = {
                    Invisible = true,
                    Destroy = true
                },
                TextLabels = {
                    LowerQuality = true,
                    Invisible = true,
                    Destroy = false
                },
                MeshParts = {
                    LowerQuality = true,
                    Invisible = true,
                    NoTexture = false,
                    NoMesh = false,
                    Destroy = false
                },
                Other = {
                    ["FPS Cap"] = 999, -- Set this true to uncap FPS
                    ["No Camera Effects"] = true,
                    ["No Clothes"] = true,
                    ["Low Water Graphics"] = true,
                    ["No Shadows"] = true,
                    ["Low Rendering"] = true,
                    ["Low Quality Parts"] = true,
                    ["Low Quality Models"] = true,
                    ["Reset Materials"] = true,
                    ["Lower Quality MeshParts"] = true
                }
            }
        end
        local Players, Lighting, StarterGui, MaterialService = game:GetService("Players"), game:GetService("Lighting"), game:GetService("StarterGui"), game:GetService("MaterialService")
        local ME, CanBeEnabled = Players.LocalPlayer, {"ParticleEmitter", "Trail", "Smoke", "Fire", "Sparkles"}
        local function PartOfCharacter(Instance)
            for i, v in pairs(Players:GetPlayers()) do
                if v ~= ME and v.Character and Instance:IsDescendantOf(v.Character) then
                    return true
                end
            end
            return false
        end
        local function DescendantOfIgnore(Instance)
            for i, v in pairs(_G.Ignore) do
                if Instance:IsDescendantOf(v) then
                    return true
                end
            end
            return false
        end
        local function CheckIfBad(Instance)
            if not Instance:IsDescendantOf(Players) and (_G.UwpOptimize.Players["Ignore Others"] and not PartOfCharacter(Instance) or not _G.UwpOptimize.Players["Ignore Others"]) and (_G.UwpOptimize.Players["Ignore Me"] and ME.Character and not Instance:IsDescendantOf(ME.Character) or not _G.UwpOptimize.Players["Ignore Me"]) and (_G.UwpOptimize.Players["Ignore Tools"] and not Instance:IsA("BackpackItem") and not Instance:FindFirstAncestorWhichIsA("BackpackItem") or not _G.UwpOptimize.Players["Ignore Tools"])--[[not PartOfCharacter(Instance)]] and (_G.Ignore and not table.find(_G.Ignore, Instance) and not DescendantOfIgnore(Instance) or (not _G.Ignore or type(_G.Ignore) ~= "table" or #_G.Ignore <= 0)) then
                if Instance:IsA("DataModelMesh") then
                    if _G.UwpOptimize.Meshes.NoMesh and Instance:IsA("SpecialMesh") then
                        Instance.MeshId = ""
                    end
                    if _G.UwpOptimize.Meshes.NoTexture and Instance:IsA("SpecialMesh") then
                        Instance.TextureId = ""
                    end
                    if _G.UwpOptimize.Meshes.Destroy or _G.UwpOptimize["No Meshes"] then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("FaceInstance") then
                    if _G.UwpOptimize.Images.Invisible then
                        Instance.Transparency = 1
                        Instance.Shiny = 1
                    end
                    if _G.UwpOptimize.Images.LowDetail then
                        Instance.Shiny = 1
                    end
                    if _G.UwpOptimize.Images.Destroy then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("ShirtGraphic") then
                    if _G.UwpOptimize.Images.Invisible then
                        Instance.Graphic = ""
                    end
                    if _G.UwpOptimize.Images.Destroy then
                        Instance:Destroy()
                    end
                elseif table.find(CanBeEnabled, Instance.ClassName) then
                    if _G.UwpOptimize["Invisible Particles"] or _G.UwpOptimize["No Particles"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Invisible Particles"]) or (_G.UwpOptimize.Particles and _G.UwpOptimize.Particles.Invisible) then
                        Instance.Enabled = false
                    end
                    if (_G.UwpOptimize.Other and _G.UwpOptimize.Other["No Particles"]) or (_G.UwpOptimize.Particles and _G.UwpOptimize.Particles.Destroy) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("PostEffect") and (_G.UwpOptimize["No Camera Effects"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["No Camera Effects"])) then
                    Instance.Enabled = false
                elseif Instance:IsA("Explosion") then
                    if _G.UwpOptimize["Smaller Explosions"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Smaller Explosions"]) or (_G.UwpOptimize.Explosions and _G.UwpOptimize.Explosions.Smaller) then
                        Instance.BlastPressure = 1
                        Instance.BlastRadius = 1
                    end
                    if _G.UwpOptimize["Invisible Explosions"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Invisible Explosions"]) or (_G.UwpOptimize.Explosions and _G.UwpOptimize.Explosions.Invisible) then
                        Instance.BlastPressure = 1
                        Instance.BlastRadius = 1
                        Instance.Visible = false
                    end
                    if _G.UwpOptimize["No Explosions"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["No Explosions"]) or (_G.UwpOptimize.Explosions and _G.UwpOptimize.Explosions.Destroy) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("Clothing") or Instance:IsA("SurfaceAppearance") or Instance:IsA("BaseWrap") then
                    if _G.UwpOptimize["No Clothes"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["No Clothes"]) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("BasePart") and not Instance:IsA("MeshPart") then
                    if _G.UwpOptimize["Low Quality Parts"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Low Quality Parts"]) then
                        Instance.Material = Enum.Material.Plastic
                        Instance.Reflectance = 0
                    end
                elseif Instance:IsA("TextLabel") and Instance:IsDescendantOf(workspace) then
                    if _G.UwpOptimize["Lower Quality TextLabels"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Lower Quality TextLabels"]) or (_G.UwpOptimize.TextLabels and _G.UwpOptimize.TextLabels.LowerQuality) then
                        Instance.Font = Enum.Font.SourceSans
                        Instance.TextScaled = false
                        Instance.RichText = false
                        Instance.TextSize = 14
                    end
                    if _G.UwpOptimize["Invisible TextLabels"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Invisible TextLabels"]) or (_G.UwpOptimize.TextLabels and _G.UwpOptimize.TextLabels.Invisible) then
                        Instance.Visible = false
                    end
                    if _G.UwpOptimize["No TextLabels"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["No TextLabels"]) or (_G.UwpOptimize.TextLabels and _G.UwpOptimize.TextLabels.Destroy) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("Model") then
                    if _G.UwpOptimize["Low Quality Models"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Low Quality Models"]) then
                        Instance.LevelOfDetail = 1
                    end
                elseif Instance:IsA("MeshPart") then
                    if _G.UwpOptimize["Low Quality MeshParts"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Low Quality MeshParts"]) or (_G.UwpOptimize.MeshParts and _G.UwpOptimize.MeshParts.LowerQuality) then
                        Instance.RenderFidelity = 2
                        Instance.Reflectance = 0
                        Instance.Material = Enum.Material.Plastic
                    end
                    if _G.UwpOptimize["Invisible MeshParts"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Invisible MeshParts"]) or (_G.UwpOptimize.MeshParts and _G.UwpOptimize.MeshParts.Invisible) then
                        Instance.Transparency = 1
                        Instance.RenderFidelity = 2
                        Instance.Reflectance = 0
                        Instance.Material = Enum.Material.Plastic
                    end
                    if _G.UwpOptimize.MeshParts and _G.UwpOptimize.MeshParts.NoTexture then
                        Instance.TextureID = ""
                    end
                    if _G.UwpOptimize.MeshParts and _G.UwpOptimize.MeshParts.NoMesh then
                        Instance.MeshId = ""
                    end
                    if _G.UwpOptimize["No MeshParts"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["No MeshParts"]) or (_G.UwpOptimize.MeshParts and _G.UwpOptimize.MeshParts.Destroy) then
                        Instance:Destroy()
                    end
                end
            end
        end
        if _G.SendNotifications then
            StarterGui:SetCore("SendNotification", {
                Title = "discord.gg/rips",
                Text = "Loading FPS Booster...",
                Duration = math.huge,
                Button1 = "Okay"
            })
        end
        coroutine.wrap(pcall)(function()
            if (_G.UwpOptimize["Low Water Graphics"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Low Water Graphics"])) then
                if not workspace:FindFirstChildOfClass("Terrain") then
                    repeat
                        task.wait()
                    until workspace:FindFirstChildOfClass("Terrain")
                end
                workspace:FindFirstChildOfClass("Terrain").WaterWaveSize = 0
                workspace:FindFirstChildOfClass("Terrain").WaterWaveSpeed = 0
                workspace:FindFirstChildOfClass("Terrain").WaterReflectance = 0
                workspace:FindFirstChildOfClass("Terrain").WaterTransparency = 0
                if sethiddenproperty then
                    sethiddenproperty(workspace:FindFirstChildOfClass("Terrain"), "Decoration", false)
                else
                    StarterGui:SetCore("SendNotification", {
                        Title = "discord.gg/rips",
                        Text = "Your exploit does not support sethiddenproperty, please use a different exploit.",
                        Duration = 5,
                        Button1 = "Okay"
                    })
                    warn("Your exploit does not support sethiddenproperty, please use a different exploit.")
                end
                if _G.SendNotifications then
                    StarterGui:SetCore("SendNotification", {
                        Title = "discord.gg/rips",
                        Text = "Low Water Graphics Enabled",
                        Duration = 5,
                        Button1 = "Okay"
                    })
                end
                if _G.ConsoleLogs then
                    warn("Low Water Graphics Enabled")
                end
            end
        end)
        coroutine.wrap(pcall)(function()
            if _G.UwpOptimize["No Shadows"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["No Shadows"]) then
                Lighting.GlobalShadows = false
                Lighting.FogEnd = 9e9
                Lighting.ShadowSoftness = 0
                if sethiddenproperty then
                    sethiddenproperty(Lighting, "Technology", 2)
                else
                    StarterGui:SetCore("SendNotification", {
                        Title = "discord.gg/rips",
                        Text = "Your exploit does not support sethiddenproperty, please use a different exploit.",
                        Duration = 5,
                        Button1 = "Okay"
                    })
                    warn("Your exploit does not support sethiddenproperty, please use a different exploit.")
                end
                if _G.SendNotifications then
                    StarterGui:SetCore("SendNotification", {
                        Title = "discord.gg/rips",
                        Text = "No Shadows Enabled",
                        Duration = 5,
                        Button1 = "Okay"
                    })
                end
                if _G.ConsoleLogs then
                    warn("No Shadows Enabled")
                end
            end
        end)
        coroutine.wrap(pcall)(function()
            if _G.UwpOptimize["Low Rendering"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Low Rendering"]) then
                settings().Rendering.QualityLevel = 1
                settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level04
                if _G.SendNotifications then
                    StarterGui:SetCore("SendNotification", {
                        Title = "discord.gg/rips",
                        Text = "Low Rendering Enabled",
                        Duration = 5,
                        Button1 = "Okay"
                    })
                end
                if _G.ConsoleLogs then
                    warn("Low Rendering Enabled")
                end
            end
        end)
        coroutine.wrap(pcall)(function()
            if _G.UwpOptimize["Reset Materials"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["Reset Materials"]) then
                for i, v in pairs(MaterialService:GetChildren()) do
                    v:Destroy()
                end
                MaterialService.Use2022Materials = false
                if _G.SendNotifications then
                    StarterGui:SetCore("SendNotification", {
                        Title = "discord.gg/rips",
                        Text = "Reset Materials Enabled",
                        Duration = 5,
                        Button1 = "Okay"
                    })
                end
                if _G.ConsoleLogs then
                    warn("Reset Materials Enabled")
                end
            end
        end)
        coroutine.wrap(pcall)(function()
            if _G.UwpOptimize["FPS Cap"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["FPS Cap"]) then
                if setfpscap then
                    if type(_G.UwpOptimize["FPS Cap"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["FPS Cap"])) == "string" or type(_G.UwpOptimize["FPS Cap"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["FPS Cap"])) == "number" then
                        setfpscap(tonumber(_G.UwpOptimize["FPS Cap"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["FPS Cap"])))
                        if _G.SendNotifications then
                            StarterGui:SetCore("SendNotification", {
                                Title = "discord.gg/rips",
                                Text = "FPS Capped to " .. tostring(_G.UwpOptimize["FPS Cap"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["FPS Cap"])),
                                Duration = 5,
                                Button1 = "Okay"
                            })
                        end
                        if _G.ConsoleLogs then
                            warn("FPS Capped to " .. tostring(_G.UwpOptimize["FPS Cap"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["FPS Cap"])))
                        end
                    elseif _G.UwpOptimize["FPS Cap"] or (_G.UwpOptimize.Other and _G.UwpOptimize.Other["FPS Cap"]) == true then
                        setfpscap(1e6)
                        if _G.SendNotifications then
                            StarterGui:SetCore("SendNotification", {
                                Title = "discord.gg/rips",
                                Text = "FPS Uncapped",
                                Duration = 5,
                                Button1 = "Okay"
                            })
                        end
                        if _G.ConsoleLogs then
                            warn("FPS Uncapped")
                        end
                    end
                else
                    StarterGui:SetCore("SendNotification", {
                        Title = "discord.gg/rips",
                        Text = "FPS Cap Failed",
                        Duration = math.huge,
                        Button1 = "Okay"
                    })
                    warn("FPS Cap Failed")
                end
            end
        end)
        game.DescendantAdded:Connect(function(value)
            wait(_G.LoadedWait or 1)
            CheckIfBad(value)
        end)
        local Descendants = game:GetDescendants()
        local StartNumber = _G.WaitPerAmount or 500
        local WaitNumber = _G.WaitPerAmount or 500
        if _G.SendNotifications then
            StarterGui:SetCore("SendNotification", {
                Title = "discord.gg/rips",
                Text = "Checking " .. #Descendants .. " Instances...",
                Duration = 15,
                Button1 = "Okay"
            })
        end
        if _G.ConsoleLogs then
            warn("Checking " .. #Descendants .. " Instances...")
        end
        for i, v in pairs(Descendants) do
            CheckIfBad(v)
            if i == WaitNumber then
                task.wait()
                if _G.ConsoleLogs then
                    print("Loaded " .. i .. "/" .. #Descendants)
                end
                WaitNumber = WaitNumber + StartNumber
            end
        end
        --game.DescendantAdded:Connect(CheckIfBad)
        --[[game.DescendantAdded:Connect(function(value)
            CheckIfBad(value)
        end)]]
    end,
})
